邮箱通信 (Mailbox) 实现
[变更内容]
新增邮箱模块：
1.实现了 mbox_create, mbox_delete, mbox_post, mbox_fetch 接口。
**mbox_fetch** (消费者)：
判空：如果邮箱为空（is_full == 0）。
动作：当前任务进入 阻塞态（移出就绪表 -> 挂入目标邮箱的等待列表 mbox->wait_list）。
结果：任务挂起，等待被投递动作唤醒。

**mbox_post** (生产者)：
判等：检查 wait_list 是否有任务在排队。
动作：如果有，说明有任务急需这个数据。
存数据：将数据存入邮箱缓冲区 (mbox->msg)。
唤醒：将等待任务移出 wait_list -> 放入 ReadyList -> 触发调度。
结果：等待的任务醒来后，直接从邮箱缓冲区拿走数据。

2. 补充一点“邮箱独有”的特性
你总结的逻辑其实也适用于队列（Queue）。邮箱 (Mailbox) 与 队列 在 mbox_post 上有一个核心区别，建议在说明中体现出来：
队列：如果没人在等，且队列满了，发送会失败或阻塞。
邮箱：如果没人在等，且邮箱满了（已经有个旧数据），发送会直接覆盖 (Overwrite) 旧数据。这是邮箱最重要的特性（保证获取最新值）。

3.数据结构采用 void *msg 指针，支持任意类型数据的引用传递。

[邮箱机制]
**1. 为什么引入邮箱 (Mailbox)？**
*表层原因* 解耦通信 (Decoupling)：
它允许发送者和接收者完全互不认识。发送者只需要把数据扔进“公共信箱”，而不需要像任务通知那样持有接收者的句柄（TCB指针）。这使得代码模块化程度更高。

*根本原因* 内核对象独立性：
任务通知是依附于 TCB 存在的，生命周期与任务绑定。而邮箱是 独立的内核对象，它的生命周期由 create 和 delete 控制。这意味着即使任务死掉了，邮箱里的数据依然可以存在，供其他任务读取。

**2. 邮箱与任务通知的数据传递区别**
*表层区别* 数据载体：
任务通知传递 uint32_t（数值）；邮箱传递 void*（指针）。
*根本原因* 内存架构差异：
任务通知 设计为贴合 CPU 寄存器 宽度（32位），追求的是寄存器级的读写速度和位图操作能力。
邮箱 设计为贴合 内存寻址。通过传递 void* 指针，实现了 “零拷贝 (Zero-Copy)”。无论数据结构有多大（例如 1KB 的结构体），内核只搬运 4 字节的地址，极大提高了大数据量的传输效率。

**3. 覆盖写入 (Overwrite) 机制**
*表层现象* 功能表现：
当邮箱已满（已有数据未被取走）时，新的 post 操作不会阻塞发送者，而是直接覆盖旧数据。
*根本原因* 设计哲学：
这解决了 “数据时效性” 问题。在实时系统中（如传感器采样），如果消费者处理不过来，积压的旧数据往往是没有价值的。
通过覆盖机制，保证了消费者每次醒来拿到的都是 当前最新 的状态，而不是几百毫秒前的历史数据，且保证了生产者（如 ISR）永远不会因为缓冲区满而卡死。

[测试程序说明]
场景逻辑： 构建了“按键触发 -> 字符串传输”模型：

消费者：
task_led1 和 task_led2 启动后调用 mbox_fetch，因邮箱为空立即进入阻塞。
生产者：
按下 KEY1：向 mbox_led1 发送字符串指针 "The first led is working."。
按下 KEY2：向 mbox_led2 发送字符串指针 "The second led is working."。

现象：对应任务被唤醒，解除阻塞，打印接收到的字符串内容并执行 LED 闪烁，验证了指针传递与阻塞同步机制的正确性。