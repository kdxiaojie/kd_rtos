[变更内容]

[通知概念]
任务通知 (Task Notification) 是一种 轻量级、直接 的任务间通信 (IPC) 机制。
*本质逻辑*： 它是将同步机制 内嵌 到了任务控制块 (TCB) 中。不像信号量或队列需要创建独立的内核对象（公共容器），任务通知直接利用目标任务 TCB 中的私有字段（notify_value 和 notify_state）来充当“私有信箱”。
*等待机制* (Wait/Block)： 当任务等待通知时，它不需要挂载到某个外部的等待列表，而是直接修改自身的 通知状态（如设为 WAITING），随后主动将自己从 就绪列表 (ReadyList) 中移除，让出 CPU 进入阻塞态。
*唤醒机制* (Notify/Wake)： 发送方不需要遍历复杂的等待队列，而是直接通过 任务句柄 定位目标 TCB。它直接修改目标任务的 通知值 和 状态（如设为 PENDING），如果目标任务正处于阻塞态，则直接将其移回 就绪列表，使其准备运行。

**结构上的区别**
[普通信号量]
你需要创建一个独立的结构体 sem_t（包含 count 和 wait_list）。
它像一个 “公共信箱”。任何任务都可以往里投信，任何任务也都可以去取信。
任务阻塞时，是挂在这个信箱的 wait_list 上。
[任务通知]
不需要创建任何额外的结构体变量。
它利用的是 TCB 自带的字段 (notify_value 和 notify_state)。
它像一个 “私人手机”。只有拥有这个任务句柄（手机号）的人，才能直接发消息给它。
任务阻塞时，它不挂在任何外部列表上，而是处于一种 “虚无” 的等待状态（只存在于内存中，不在就绪表，也不在延时表），直到有人通过句柄找到它，把它直接拉回就绪表。

[value的作用]
不用它：就是纯唤醒（同步）。
用它存数：就是通信（传递数据）。
用它存位：就是事件标志。

**效率上的区别**
更快：不需要遍历信号量的等待列表来找“谁在等”，因为发送者直接拿着目标任务的指针 (target_tcb)，直接操作内存，速度极快。
更省：省去了一个信号量对象的 RAM 开销。

1. 核心通信机制扩充 (Core Communication):
   - 引入 **任务通知 (Task Notifications)**：一种比信号量和队列更轻量级、速度更快的任务间直接通信机制。
   - 新增 TCB 字段：在 `task_tcb` 结构体中增加了 `notify_value` (通知值) 和 `notify_state` (通知状态) 字段，无需创建额外的内核对象即可实现同步与通信。
   - 新增 API：
     - `task_notify(task_tcb *target, uint32_t value)`：向指定任务发送信号/数据，并唤醒该任务。
     - `task_wait_notify(void)`：等待通知。若无通知则挂起当前任务（移出就绪表），收到通知后自动唤醒并返回数据。

2. 通信逻辑实现原理 (Implementation Logic):
   - **点对点直达**：摒弃了信号量“公共容器”的概念，发送方直接操作目标任务的 TCB。逻辑上类似于“直接把信塞进对方口袋”，省去了遍历等待列表 (WaitList) 的开销。
   - **状态机流转**：引入 `NOTIFY_NONE` (无)、`NOTIFY_PENDING` (有信未读)、`NOTIFY_WAITING` (死等中) 三种状态。
   - **原子性消费**：`task_wait_notify` 在返回数据的同时自动清除通知状态，保证了数据读取与状态复位的原子性，防止重复处理。

3. 应用层适配与测试:
   - 更新 `main.c` 测试场景：构建了“按键计数-定向分发”模型。
   - 生产者逻辑：按键任务维护一个计数器，按下 KEY1/KEY2 时，直接通过任务句柄 (`task_tcb*`) 将计数值发送给对应的 LED 任务。
   - 消费者逻辑：LED 任务平时处于阻塞状态，接收到特定通知值后被定向唤醒，打印数据并执行闪烁。
   - **修正调用规范**：明确了 `task_notify` 必须传入任务句柄（TCB指针）而非任务函数地址，修复了潜在的非法内存访问风险。

[技术意义]
实现了RTOS中最高效的通信手段。相比于信号量和队列，任务通知机制**零内存开销**（不需要创建独立变量）且**调度延迟更低**（无需操作复杂的等待链表），非常适合高频且明确收发对象的同步场景（如 ISR 到任务的事件通知）。


FreeRtos深入理解：
**死循环的作用**（表层原因）：
它确保了任务函数作为一个永久的执行框架。
这个框架为任务的所有局部变量提供了一个稳定的、顶层的栈空间。如果没有死循环，函数一返回，整个栈帧就被回收了，任务也就结束了。
**上下文切换机制的作用**（根本原因）：
当任务因延迟、等待信号等原因被切换出去时，CPU的整个状态（包括所有寄存器，尤其是栈指针SP和程序计数器PC）都被完整地保存到该任务的私有栈中。
此时，localCounter 这个变量的值，可能存在于CPU的寄存器中，也可能已经被压入了任务的私有栈。
当任务被再次调度时，操作系统做的第一件事就是把之前保存的整个状态（上下文）从私有栈中“原封不动”地恢复到CPU寄存器中。这包括：
恢复栈指针，重新指向这个任务的私有栈。
恢复所有通用寄存器的值。
恢复程序计数器，让CPU接着上次被中断的代码继续执行。