统安全增强：临界区保护 (Critical Section)

[变更内容]
1. 新增嵌套临界区机制 (Nested Critical Section)
接口实现：实现了 task_enter_critical (进入) 和 task_exit_critical (退出) 接口。
嵌套计数：引入全局计数器 critical_nesting。进入时关中断并计数+1，退出时计数-1。仅当计数器减至 0 时，才执行开中断指令。
软件死延时：引入 soft_delay (纯 CPU 空转延时)，用于解决在临界区内无法使用 SysTick 延时的问题。

2. 内核 API 安全重构
原子性保障：将内核所有核心函数（如 os_delay, sem_take, mbox_post, bitmap_set 等）内部的原生开关中断指令 (__disable_irq/__enable_irq) 全部替换为新的 临界区接口。
防止保护失效：确保了内核函数被嵌套调用时，不会意外提前开启中断，破坏外部调用者的临界区保护。

[临界区机制深究]
1. 为什么引入临界区？
表层原因 (数据一致性)： 在多任务环境下，内核的共享资源（如就绪链表、优先级位图、内存堆）在操作过程中严禁被中断打断。否则会导致链表指针断裂或数据错乱。
根本原因 (原子性 Atomicity)： 在单核 MCU 上，实现原子操作最底层的手段是 屏蔽硬件中断。通过拉下“总闸” (PRIMASK)，屏蔽 SysTick (调度源) 和外部中断，从而构建一个绝对安全、独占 CPU 的时间窗口。

2. 为什么要支持“嵌套”？
表层现象 (调用链安全)： 当父函数进入临界区后调用子函数，子函数内部也需要临界区保护。如果使用原生的开关中断指令，子函数执行完 __enable_irq 会强行开启中断，导致父函数后续的敏感代码失去保护（"裸奔"）。
根本原因 (逻辑闭环)： 通过引入 nesting 计数器，将硬件的中断状态与软件的调用深度解耦。它确保了中断状态的改变严格遵循调用栈的深度：谁上的最后一把锁，谁才能彻底解开锁。

*踩坑实录 & 关键修复 (CRITICAL)*
本次更新修复了两个在临界区开发中极易遇到的逻辑死锁问题：
1. 临界区内的“时钟停摆”死锁
问题描述：在调用 task_enter_critical 后，若代码中调用了依赖 SysTick 的延时函数 (如 cpu_delay_ms)，系统会永久冻结。
根本原因：临界区关闭了硬件中断，导致 SysTick 定时器中断无法触发，全局 Tick 计数器停止更新。cpu_delay_ms 内部的 while 循环条件永远无法满足，导致 CPU 陷入死循环。
解决方案：确立开发铁律——临界区内严禁调用任何依赖中断或调度的 API。对于必须的短延时（如硬件时序），使用 soft_delay (汇编空指令循环) 替代。

2. 任务调度与临界区的冲突
问题描述：在按键任务测试中，进入临界区后调用 os_delay，导致系统逻辑混乱。
根本原因：os_delay 的核心逻辑是“触发 PendSV 进行任务切换”。但在临界区（关中断）状态下，PendSV 请求会被挂起无法响应，任务试图让出 CPU 却无法切走，逻辑自相矛盾。
解决方案：在 os_delay 内部增加防御性判断 if (critical_nesting > 0) return;，并配合 task_key_func 中的逻辑修正：在临界区内强制使用软件延时，保持 CPU 霸占状态直到退出临界区。

[测试程序说明]
场景逻辑： 构建了“按键触发 -> 临界区冻结”模型验证机制的有效性：
正常状态： task_led1 和 task_led2 正常交替闪烁，SysTick 心跳正常。
进入临界区：
按下 KEY1：调用 task_enter_critical。
现象：LED 瞬间 停止闪烁 (保持常亮或常灭)，串口不再有新打印。证明 SysTick 和 PendSV 均已被屏蔽，系统进入“冻结”状态。
退出临界区：
按下 KEY2：调用 task_exit_critical。
现象：LED 瞬间恢复闪烁，系统恢复心跳与调度。证明嵌套计数归零，中断成功重新开启。