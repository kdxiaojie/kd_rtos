版本更新日志：同步通信机制与信号量实现

[新增功能]
事件控制块 (ECB) 架构 引入了 Event Control Block (ECB) 基础结构，作为所有任务间通信机制（信号量、互斥锁、邮箱）的通用底层容器。ECB 包含了一个核心的等待链表 (WaitList)，用于管理所有因等待特定事件而挂起的任务。
计数信号量 (Counting Semaphore) 实现了完整的信号量机制，支持任务间的同步与互斥访问。 提供 sem_init (静态初始化) 与 sem_create (动态创建) 接口。 提供 sem_take (获取/P操作) 与 sem_give (释放/V操作) 接口。

[核心逻辑实现原理]
信号量机制本质解析： 信号量的本质是定义一个计数变量。当任务执行 sem_take 获取信号量时，如果变量有值（大于0），任务消耗一个资源并继续执行；否则，系统会将该任务从“就绪链表”中移除。注意，此时任务不会被放入延时链表，而是被放入该信号量专属的“排队链表 (WaitList)”中，进入挂起状态等待资源。

当有其他任务执行 sem_give 释放信号量时，系统会检查该信号量的排队链表。如果有任务在排队，系统采用“资源直接传递”策略：直接将释放的资源移交给等待队列中的第一个任务（计数器不增加），并将该任务从排队链表移出，重新放入“就绪链表”，触发调度使其立即抢占运行。如果排队链表为空，则信号量计数器加1。

[验证与测试]
构建了“按键生产者-LED消费者”模型验证同步机制： 消费者任务（High/Low Priority）：启动后尝试获取初始值为0的信号量，随即进入阻塞状态，LED保持熄灭。 生产者任务（Key Task）：检测按键按下后释放信号量。 现象：按下按键瞬间，消费者任务被立即唤醒并抢占 CPU 执行 LED 闪烁逻辑，证明信号量挂起与唤醒机制运行正确，实现了任务间的事件驱动同步。