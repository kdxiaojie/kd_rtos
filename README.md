实现上下文切换
RTOS的核心就是为每个函数建立一个私有栈，然后当切换到一个任务时，该任务从其私有栈将信息提供给cpu寄存器执行，任务被打断或主动让出后将信息又保存到自己的私有栈。



这是一份可以作为 Cortex-M4 内核微架构运行指南 的文档。
序幕：伪造现场 (C语言准备)
(注：这是静态准备，在 RAM 中写入数据，尚未涉及 CPU 寄存器搬运，故保持原描述) 状态：堆内存中有一块连续区域，被填满了数据（0 和 函数地址）。

第一幕：创世纪 (os_start) —— 手动搬运与复活
场景：系统刚启动，CPU 运行在 MSP 模式。

1. LDR R0, [R1] (获取栈指针)
物理动作：CPU 访问 RAM 中 current_tcb 结构体的首地址，读取 4 字节数据，写入 R0 寄存器。

寄存器内容：R0 变成了 Task1 伪造栈的栈底地址（指向伪造的 R4 位置）。

指针指向：R0 作为一个临时指针，指向了堆内存中 Task1 数据的起始位置。

2. LDMIA R0!, {R4-R11} (恢复软件帧)
物理动作：

读取内存：CPU 从 R0 当前指向的地址开始，连续读取 8 个 32 位数据（32字节）。

写入寄存器：CPU 将读到的这 8 个数据，分别写入内部的 R4 到 R11 物理寄存器。

更新指针：CPU 将 R0 寄存器的值增加 32。

寄存器内容：R4 到 R11 全部变成了 0（因为你在 C 语言里填的是 0）。

指针指向：R0 增加了 32 字节，现在指向了 硬件帧的开头（即伪造的 R0 的内存位置）。

3. MSR PSP, R0 (偷梁换柱)
物理动作：CPU 将通用寄存器 R0 里的值，复制到特殊寄存器 PSP (Process Stack Pointer) 中。

寄存器内容：PSP 寄存器现在变成了 R0 的值（即指向硬件帧开头）。

指针指向：PSP 指针现在正式指向了 Task1 栈中伪造的 R0 位置。

4. LDMIA SP!, {R0-R3} (剥离 R0-R3)
(注：此时 SP 已经是 PSP)

物理动作：

读取内存：CPU 从 SP (PSP) 指向的地址，连续读取 4 个 32 位数据。

写入寄存器：写入 CPU 内部的 R0, R1, R2, R3。

更新指针：CPU 将 SP 的值增加 16。

寄存器内容：R0, R1, R2, R3 变成了 0。我们不在乎这个值（丢弃）。

指针指向：SP 增加了 16 字节，现在指向了 R12 的内存位置。

5. LDMIA SP!, {R12} (剥离 R12)
物理动作：读取 SP 指向的 1 个字，写入 R12，SP 加 4。

寄存器内容：R12 变成了 0。

指针指向：SP 增加了 4 字节，现在指向了 LR 的内存位置。

6. LDMIA SP!, {R14} (恢复 LR)
物理动作：读取 SP 指向的 1 个字，写入 R14 (LR)，SP 加 4。

寄存器内容：R14 变成了 0（这是我们在 C 语言填入的返回地址，防止任务错误返回）。

指针指向：SP 增加了 4 字节，现在指向了 PC 的内存位置（这是最关键的数据！）。

7. LDMIA SP!, {R6} (获取入口地址)
物理动作：读取 SP 指向的 1 个字，写入 R6，SP 加 4。

寄存器内容：R6 变成了 led_on 函数的入口地址（例如 0x08001234）。

指针指向：SP 增加了 4 字节，现在指向了 xPSR 的内存位置。

8. LDMIA SP!, {R7} (剥离 xPSR)
物理动作：读取 SP 指向的 1 个字，写入 R7，SP 加 4。

寄存器内容：R7 变成了状态字（0x01000000）。

指针指向：SP 增加了 4 字节，现在指向了 空闲区域（栈顶）。

结论：伪造栈彻底处理完毕，SP 指向了干净的空地，随时准备接受新数据。

9. BX R6 (起飞)
物理动作：CPU 将 R6 寄存器的值，直接复制给 PC (Program Counter) 寄存器。

寄存器内容：PC 变成了 0x08001234 (led_on 地址)。

结果：CPU 的指令预取单元立即跳转到该地址，开始执行 C 代码。

第二幕：日常轮回 (PendSV_Handler) —— 真实数据的保存与恢复
场景：任务 A 运行中，触发中断。硬件已自动压入硬件帧 (R0-R3, R12, LR, PC, xPSR)。现在 CPU 处于 MSP 模式。

1. MRS R0, PSP (读取当前栈指针)
物理动作：CPU 将特殊寄存器 PSP 的值，复制到通用寄存器 R0。

寄存器内容：R0 变成了任务 A 当前的栈顶地址（此时指向刚被硬件压入的 R0 的下方）。

指针指向：R0 作为一个临时指针，指向了栈顶。

2. STMDB R0!, {R4-R11} (保存软件帧)
物理动作：

更新指针：CPU 先将 R0 的值减去 32（8个字 × 4字节）。

写入内存：CPU 将 R4 到 R11 寄存器里的当前值，连续写入到 R0 新指向的内存区域。

寄存器内容：R4-R11 的值保持不变（只是复制了一份到内存）。

指针指向：R0 指向了 软件帧的最低地址（栈底）。现在栈里保存了完整的任务 A 现场。

3. STR R0, [R2] (保存指针)
物理动作：将 R0 的值写入到 R2 指向的内存地址（即 current_tcb->stack_ptr）。

结果：任务 A 的最新栈顶地址被记录在案，下次回来就靠它找数据。

4. LDR R0, [R2] (获取新任务栈指针)
物理动作：从 next_tcb->stack_ptr 读取 4 字节数据到 R0。

寄存器内容：R0 变成了 Task 2 上次暂停时的栈顶地址（指向 Task 2 栈里的 R4）。

指针指向：R0 指向 Task 2 的软件帧栈底。

5. LDMIA R0!, {R4-R11} (恢复新任务软件帧)
物理动作：

读取内存：从 R0 指向的地址读取 8 个字。

写入寄存器：覆盖 CPU 的 R4 到 R11 寄存器。

更新指针：R0 增加 32。

寄存器内容：R4-R11 变成了 Task 2 上次暂停时的值（例如 Task 2 的局部变量）。

指针指向：R0 现在指向了 Task 2 的 硬件帧开头 (R0)。

6. MSR PSP, R0 (更新硬件指针)
物理动作：将 R0 的值写入 PSP 寄存器。

寄存器内容：PSP 现在指向了 Task 2 的硬件帧。

意义：为接下来的硬件自动出栈做好了准备。

7. BX R14 (硬件自动回弹)
物理动作：

CPU 检测到 R14 是魔法数 0xFFFFFFFD。

切换栈：将当前使用的栈从 MSP 切换回 PSP。

自动读取内存：从 PSP 指向的地址连续读取 8 个字 (R0-R3, R12, LR, PC, xPSR)。

自动写入寄存器：覆盖 CPU 对应的物理寄存器。

自动更新指针：PSP 增加 32，指向空闲区域。

寄存器内容：PC 变成了 Task 2 的断点地址，R0-R3 变成了 Task 2 的计算数据。

结果：CPU 无缝衔接到 Task 2 继续运行。
